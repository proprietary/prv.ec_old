/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./client/index.ts":
/*!*************************!*\
  !*** ./client/index.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LookupClient = exports.ShortenerClient = void 0;\nvar v1_1 = __webpack_require__(/*! ./v1 */ \"./client/v1.ts\");\nObject.defineProperty(exports, \"ShortenerClient\", { enumerable: true, get: function () { return v1_1.ShortenerClient; } });\nObject.defineProperty(exports, \"LookupClient\", { enumerable: true, get: function () { return v1_1.LookupClient; } });\n\n\n//# sourceURL=webpack:///./client/index.ts?");

/***/ }),

/***/ "./client/v1.ts":
/*!**********************!*\
  !*** ./client/v1.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LookupClient = exports.ShortenerClient = void 0;\nconst rpc_1 = __webpack_require__(/*! ../rpc */ \"./rpc/index.ts\");\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"./crypto.ts\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./util/index.ts\");\nconst private_url_generated_1 = __webpack_require__(/*! ../fbs/private_url_generated */ \"./fbs/private_url_generated.ts\");\nconst flatbuffers_1 = __webpack_require__(/*! ../vendor/flatbuffers/flatbuffers */ \"./vendor/flatbuffers/flatbuffers.js\");\nclass ShortenerClient {\n    constructor() {\n        this.iv_ = new Uint8Array(crypto_1.IV_BYTES_V1);\n        this.pass_ = new Uint8Array(crypto_1.PASS_BYTES_V1);\n        this.salt_ = new Uint8Array(crypto_1.SALT_BYTES_V1);\n        this.expiry_ = defaultExpiry();\n        window.crypto.getRandomValues(this.iv_);\n        window.crypto.getRandomValues(this.pass_);\n        window.crypto.getRandomValues(this.salt_);\n    }\n    async shorten(url) {\n        const key = await crypto_1.deriveKeyV1({\n            salt: this.salt_,\n            iv: this.iv_,\n            pass: this.pass_,\n        });\n        const m = await crypto_1.encryptV1({\n            key,\n            iv: this.iv_,\n            url,\n        });\n        const identifier = await rpc_1.shorteningRequestV1(new Uint8Array(m), this.iv_, this.salt_, this.expiry_);\n        const passAsStr = util_1.fromByteArray(this.pass_);\n        return /* https://prv.ec/ */ `${identifier}#${passAsStr}`;\n    }\n    set expiry(d) {\n        this.expiry_ = d;\n    }\n    get expiry() {\n        return this.expiry_;\n    }\n}\nexports.ShortenerClient = ShortenerClient;\nclass LookupClient {\n    constructor(identifier, pass) {\n        this.identifier_ = identifier;\n        if (this.identifier_.length > 10) {\n            throw new Error();\n        }\n        this.pass_ = util_1.toByteArray(pass);\n    }\n    async lookup() {\n        let r = await rpc_1.lookupRequestWeb(this.identifier_);\n        if (r == null) {\n            return '';\n        }\n        let pu = private_url_generated_1.ec_prv.fbs.PrivateURL.getRootAsPrivateURL(new flatbuffers_1.flatbuffers.ByteBuffer(new Uint8Array(r.data))).unpack();\n        const key = await crypto_1.deriveKeyV1({\n            salt: new Uint8Array(pu.salt),\n            iv: new Uint8Array(pu.iv),\n            pass: this.pass_,\n        });\n        const p = await crypto_1.decryptV1({\n            key,\n            iv: new Uint8Array(pu.iv),\n            ciphertext: new Uint8Array(pu.blindedUrl),\n        });\n        return new TextDecoder('utf-8').decode(p);\n    }\n}\nexports.LookupClient = LookupClient;\nfunction defaultExpiry() {\n    return new Date(Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 364);\n}\n\n\n//# sourceURL=webpack:///./client/v1.ts?");

/***/ }),

/***/ "./crypto.ts":
/*!*******************!*\
  !*** ./crypto.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TAG_BYTES_V1 = exports.KEY_BYTES_V1 = exports.PASS_BYTES_V1 = exports.IV_BYTES_V1 = exports.SALT_BYTES_V1 = exports.AAD_DATA_V1 = exports.DEFAULT_PBKDF2_ROUNDS_V1 = exports.decryptV1 = exports.encryptV1 = exports.deriveKeyV1 = void 0;\nasync function deriveKeyV1(options) {\n    if (options.pbkdf2Rounds == null) {\n        options.pbkdf2Rounds = exports.DEFAULT_PBKDF2_ROUNDS_V1;\n    }\n    const passKey = await window.crypto.subtle.importKey('raw', options.pass, 'PBKDF2', false, ['deriveKey']);\n    const k = await window.crypto.subtle.deriveKey({\n        name: 'PBKDF2',\n        salt: options.salt,\n        iterations: options.pbkdf2Rounds,\n        hash: 'SHA-256',\n    }, passKey, { name: 'AES-GCM', length: exports.KEY_BYTES_V1 * 8 }, true, ['encrypt', 'decrypt']);\n    return k;\n}\nexports.deriveKeyV1 = deriveKeyV1;\nasync function encryptV1(options) {\n    if (options.iv.byteLength != exports.IV_BYTES_V1) {\n        throw new Error();\n    }\n    const encoded = new TextEncoder().encode(options.url);\n    let ciphertext = await window.crypto.subtle.encrypt({\n        name: 'AES-GCM',\n        iv: options.iv,\n        additionalData: exports.AAD_DATA_V1,\n        tagLength: exports.TAG_BYTES_V1 * 8,\n    }, options.key, encoded);\n    return ciphertext;\n}\nexports.encryptV1 = encryptV1;\nasync function decryptV1(options) {\n    if (options.iv.byteLength != exports.IV_BYTES_V1) {\n        throw new Error();\n    }\n    const r = await crypto.subtle.decrypt({\n        name: 'AES-GCM',\n        iv: options.iv,\n        additionalData: exports.AAD_DATA_V1,\n        tagLength: exports.TAG_BYTES_V1 * 8,\n    }, options.key, options.ciphertext);\n    return r;\n}\nexports.decryptV1 = decryptV1;\nexports.DEFAULT_PBKDF2_ROUNDS_V1 = 2000000;\nexports.AAD_DATA_V1 = new TextEncoder().encode('www.prv.ec');\nexports.SALT_BYTES_V1 = 16;\nexports.IV_BYTES_V1 = 12;\nexports.PASS_BYTES_V1 = 3;\nexports.KEY_BYTES_V1 = 32;\nexports.TAG_BYTES_V1 = 16;\n\n\n//# sourceURL=webpack:///./crypto.ts?");

/***/ }),

/***/ "./fbs/lookup_request_generated.ts":
/*!*****************************************!*\
  !*** ./fbs/lookup_request_generated.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// automatically generated by the FlatBuffers compiler, do not modify\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ec_prv = void 0;\n/**\n * @constructor\n */\nvar ec_prv;\n(function (ec_prv) {\n    var fbs;\n    (function (fbs) {\n        class LookupRequest {\n            constructor() {\n                this.bb = null;\n                this.bb_pos = 0;\n            }\n            /**\n             * @param number i\n             * @param flatbuffers.ByteBuffer bb\n             * @returns LookupRequest\n             */\n            __init(i, bb) {\n                this.bb_pos = i;\n                this.bb = bb;\n                return this;\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param LookupRequest= obj\n             * @returns LookupRequest\n             */\n            static getRootAsLookupRequest(bb, obj) {\n                return (obj || new LookupRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param LookupRequest= obj\n             * @returns LookupRequest\n             */\n            static getSizePrefixedRootAsLookupRequest(bb, obj) {\n                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n                return (obj || new LookupRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            version() {\n                var offset = this.bb.__offset(this.bb_pos, 4);\n                return offset ? this.bb.readUint8(this.bb_pos + offset) : 1;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            lookupKey() {\n                var offset = this.bb.__offset(this.bb_pos, 6);\n                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             */\n            static startLookupRequest(builder) {\n                builder.startObject(2);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number version\n             */\n            static addVersion(builder, version) {\n                builder.addFieldInt8(0, version, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number lookupKey\n             */\n            static addLookupKey(builder, lookupKey) {\n                builder.addFieldInt32(1, lookupKey, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            static endLookupRequest(builder) {\n                var offset = builder.endObject();\n                return offset;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishLookupRequestBuffer(builder, offset) {\n                builder.finish(offset);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishSizePrefixedLookupRequestBuffer(builder, offset) {\n                builder.finish(offset, undefined, true);\n            }\n            ;\n            static createLookupRequest(builder, version, lookupKey) {\n                LookupRequest.startLookupRequest(builder);\n                LookupRequest.addVersion(builder, version);\n                LookupRequest.addLookupKey(builder, lookupKey);\n                return LookupRequest.endLookupRequest(builder);\n            }\n            /**\n             * @returns LookupRequestT\n             */\n            unpack() {\n                return new LookupRequestT(this.version(), this.lookupKey());\n            }\n            ;\n            /**\n             * @param LookupRequestT _o\n             */\n            unpackTo(_o) {\n                _o.version = this.version();\n                _o.lookupKey = this.lookupKey();\n            }\n            ;\n        }\n        fbs.LookupRequest = LookupRequest;\n        class LookupRequestT {\n            /**\n             * @constructor\n             * @param number version\n             * @param number lookupKey\n             */\n            constructor(version = 1, lookupKey = 0) {\n                this.version = version;\n                this.lookupKey = lookupKey;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            pack(builder) {\n                return ec_prv.fbs.LookupRequest.createLookupRequest(builder, this.version, this.lookupKey);\n            }\n            ;\n        }\n        fbs.LookupRequestT = LookupRequestT;\n    })(fbs = ec_prv.fbs || (ec_prv.fbs = {}));\n})(ec_prv = exports.ec_prv || (exports.ec_prv = {}));\n\n\n//# sourceURL=webpack:///./fbs/lookup_request_generated.ts?");

/***/ }),

/***/ "./fbs/lookup_request_web_generated.ts":
/*!*********************************************!*\
  !*** ./fbs/lookup_request_web_generated.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// automatically generated by the FlatBuffers compiler, do not modify\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ec_prv = void 0;\n/**\n * @constructor\n */\nvar ec_prv;\n(function (ec_prv) {\n    var fbs;\n    (function (fbs) {\n        class LookupRequestWeb {\n            constructor() {\n                this.bb = null;\n                this.bb_pos = 0;\n            }\n            /**\n             * @param number i\n             * @param flatbuffers.ByteBuffer bb\n             * @returns LookupRequestWeb\n             */\n            __init(i, bb) {\n                this.bb_pos = i;\n                this.bb = bb;\n                return this;\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param LookupRequestWeb= obj\n             * @returns LookupRequestWeb\n             */\n            static getRootAsLookupRequestWeb(bb, obj) {\n                return (obj || new LookupRequestWeb()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param LookupRequestWeb= obj\n             * @returns LookupRequestWeb\n             */\n            static getSizePrefixedRootAsLookupRequestWeb(bb, obj) {\n                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n                return (obj || new LookupRequestWeb()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            lookupKey(optionalEncoding) {\n                var offset = this.bb.__offset(this.bb_pos, 4);\n                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             */\n            static startLookupRequestWeb(builder) {\n                builder.startObject(1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset lookupKeyOffset\n             */\n            static addLookupKey(builder, lookupKeyOffset) {\n                builder.addFieldOffset(0, lookupKeyOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            static endLookupRequestWeb(builder) {\n                var offset = builder.endObject();\n                return offset;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishLookupRequestWebBuffer(builder, offset) {\n                builder.finish(offset);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishSizePrefixedLookupRequestWebBuffer(builder, offset) {\n                builder.finish(offset, undefined, true);\n            }\n            ;\n            static createLookupRequestWeb(builder, lookupKeyOffset) {\n                LookupRequestWeb.startLookupRequestWeb(builder);\n                LookupRequestWeb.addLookupKey(builder, lookupKeyOffset);\n                return LookupRequestWeb.endLookupRequestWeb(builder);\n            }\n            /**\n             * @returns LookupRequestWebT\n             */\n            unpack() {\n                return new LookupRequestWebT(this.lookupKey());\n            }\n            ;\n            /**\n             * @param LookupRequestWebT _o\n             */\n            unpackTo(_o) {\n                _o.lookupKey = this.lookupKey();\n            }\n            ;\n        }\n        fbs.LookupRequestWeb = LookupRequestWeb;\n        class LookupRequestWebT {\n            /**\n             * @constructor\n             * @param string|Uint8Array|null lookupKey\n             */\n            constructor(lookupKey = null) {\n                this.lookupKey = lookupKey;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            pack(builder) {\n                const lookupKey = (this.lookupKey !== null ? builder.createString(this.lookupKey) : 0);\n                return ec_prv.fbs.LookupRequestWeb.createLookupRequestWeb(builder, lookupKey);\n            }\n            ;\n        }\n        fbs.LookupRequestWebT = LookupRequestWebT;\n    })(fbs = ec_prv.fbs || (ec_prv.fbs = {}));\n})(ec_prv = exports.ec_prv || (exports.ec_prv = {}));\n\n\n//# sourceURL=webpack:///./fbs/lookup_request_web_generated.ts?");

/***/ }),

/***/ "./fbs/lookup_response_generated.ts":
/*!******************************************!*\
  !*** ./fbs/lookup_response_generated.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// automatically generated by the FlatBuffers compiler, do not modify\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ec_prv = void 0;\n/**\n * @constructor\n */\nvar ec_prv;\n(function (ec_prv) {\n    var fbs;\n    (function (fbs) {\n        class LookupResponse {\n            constructor() {\n                this.bb = null;\n                this.bb_pos = 0;\n            }\n            /**\n             * @param number i\n             * @param flatbuffers.ByteBuffer bb\n             * @returns LookupResponse\n             */\n            __init(i, bb) {\n                this.bb_pos = i;\n                this.bb = bb;\n                return this;\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param LookupResponse= obj\n             * @returns LookupResponse\n             */\n            static getRootAsLookupResponse(bb, obj) {\n                return (obj || new LookupResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param LookupResponse= obj\n             * @returns LookupResponse\n             */\n            static getSizePrefixedRootAsLookupResponse(bb, obj) {\n                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n                return (obj || new LookupResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            version() {\n                var offset = this.bb.__offset(this.bb_pos, 4);\n                return offset ? this.bb.readUint8(this.bb_pos + offset) : 1;\n            }\n            ;\n            /**\n             * @returns boolean\n             */\n            error() {\n                var offset = this.bb.__offset(this.bb_pos, 6);\n                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            data(index) {\n                var offset = this.bb.__offset(this.bb_pos, 8);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            dataLength() {\n                var offset = this.bb.__offset(this.bb_pos, 8);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            dataArray() {\n                var offset = this.bb.__offset(this.bb_pos, 8);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             */\n            static startLookupResponse(builder) {\n                builder.startObject(3);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number version\n             */\n            static addVersion(builder, version) {\n                builder.addFieldInt8(0, version, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param boolean error\n             */\n            static addError(builder, error) {\n                builder.addFieldInt8(1, +error, +false);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset dataOffset\n             */\n            static addData(builder, dataOffset) {\n                builder.addFieldOffset(2, dataOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createDataVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startDataVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            static endLookupResponse(builder) {\n                var offset = builder.endObject();\n                return offset;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishLookupResponseBuffer(builder, offset) {\n                builder.finish(offset);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishSizePrefixedLookupResponseBuffer(builder, offset) {\n                builder.finish(offset, undefined, true);\n            }\n            ;\n            static createLookupResponse(builder, version, error, dataOffset) {\n                LookupResponse.startLookupResponse(builder);\n                LookupResponse.addVersion(builder, version);\n                LookupResponse.addError(builder, error);\n                LookupResponse.addData(builder, dataOffset);\n                return LookupResponse.endLookupResponse(builder);\n            }\n            /**\n             * @returns LookupResponseT\n             */\n            unpack() {\n                return new LookupResponseT(this.version(), this.error(), this.bb.createScalarList(this.data.bind(this), this.dataLength()));\n            }\n            ;\n            /**\n             * @param LookupResponseT _o\n             */\n            unpackTo(_o) {\n                _o.version = this.version();\n                _o.error = this.error();\n                _o.data = this.bb.createScalarList(this.data.bind(this), this.dataLength());\n            }\n            ;\n        }\n        fbs.LookupResponse = LookupResponse;\n        class LookupResponseT {\n            /**\n             * @constructor\n             * @param number version\n             * @param boolean error\n             * @param (number)[] data\n             */\n            constructor(version = 1, error = false, data = []) {\n                this.version = version;\n                this.error = error;\n                this.data = data;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            pack(builder) {\n                const data = ec_prv.fbs.LookupResponse.createDataVector(builder, this.data);\n                return ec_prv.fbs.LookupResponse.createLookupResponse(builder, this.version, this.error, data);\n            }\n            ;\n        }\n        fbs.LookupResponseT = LookupResponseT;\n    })(fbs = ec_prv.fbs || (ec_prv.fbs = {}));\n})(ec_prv = exports.ec_prv || (exports.ec_prv = {}));\n\n\n//# sourceURL=webpack:///./fbs/lookup_response_generated.ts?");

/***/ }),

/***/ "./fbs/private_url_generated.ts":
/*!**************************************!*\
  !*** ./fbs/private_url_generated.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// automatically generated by the FlatBuffers compiler, do not modify\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ec_prv = void 0;\n/**\n * @constructor\n */\nvar ec_prv;\n(function (ec_prv) {\n    var fbs;\n    (function (fbs) {\n        class PrivateURL {\n            constructor() {\n                this.bb = null;\n                this.bb_pos = 0;\n            }\n            /**\n             * @param number i\n             * @param flatbuffers.ByteBuffer bb\n             * @returns PrivateURL\n             */\n            __init(i, bb) {\n                this.bb_pos = i;\n                this.bb = bb;\n                return this;\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param PrivateURL= obj\n             * @returns PrivateURL\n             */\n            static getRootAsPrivateURL(bb, obj) {\n                return (obj || new PrivateURL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param PrivateURL= obj\n             * @returns PrivateURL\n             */\n            static getSizePrefixedRootAsPrivateURL(bb, obj) {\n                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n                return (obj || new PrivateURL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            version() {\n                var offset = this.bb.__offset(this.bb_pos, 4);\n                return offset ? this.bb.readUint8(this.bb_pos + offset) : 1;\n            }\n            ;\n            /**\n             * @returns flatbuffers.Long\n             */\n            expiry() {\n                var offset = this.bb.__offset(this.bb_pos, 6);\n                return offset ? this.bb.readUint64(this.bb_pos + offset) : this.bb.createLong(0, 0);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            pbkdf2Iters() {\n                var offset = this.bb.__offset(this.bb_pos, 8);\n                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            salt(index) {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            saltLength() {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            saltArray() {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            iv(index) {\n                var offset = this.bb.__offset(this.bb_pos, 12);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            ivLength() {\n                var offset = this.bb.__offset(this.bb_pos, 12);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            ivArray() {\n                var offset = this.bb.__offset(this.bb_pos, 12);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            blindedUrl(index) {\n                var offset = this.bb.__offset(this.bb_pos, 14);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            blindedUrlLength() {\n                var offset = this.bb.__offset(this.bb_pos, 14);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            blindedUrlArray() {\n                var offset = this.bb.__offset(this.bb_pos, 14);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             */\n            static startPrivateURL(builder) {\n                builder.startObject(6);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number version\n             */\n            static addVersion(builder, version) {\n                builder.addFieldInt8(0, version, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Long expiry\n             */\n            static addExpiry(builder, expiry) {\n                builder.addFieldInt64(1, expiry, builder.createLong(0, 0));\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number pbkdf2Iters\n             */\n            static addPbkdf2Iters(builder, pbkdf2Iters) {\n                builder.addFieldInt32(2, pbkdf2Iters, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset saltOffset\n             */\n            static addSalt(builder, saltOffset) {\n                builder.addFieldOffset(3, saltOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createSaltVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startSaltVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset ivOffset\n             */\n            static addIv(builder, ivOffset) {\n                builder.addFieldOffset(4, ivOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createIvVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startIvVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset blindedUrlOffset\n             */\n            static addBlindedUrl(builder, blindedUrlOffset) {\n                builder.addFieldOffset(5, blindedUrlOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createBlindedUrlVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startBlindedUrlVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            static endPrivateURL(builder) {\n                var offset = builder.endObject();\n                return offset;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishPrivateURLBuffer(builder, offset) {\n                builder.finish(offset);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishSizePrefixedPrivateURLBuffer(builder, offset) {\n                builder.finish(offset, undefined, true);\n            }\n            ;\n            static createPrivateURL(builder, version, expiry, pbkdf2Iters, saltOffset, ivOffset, blindedUrlOffset) {\n                PrivateURL.startPrivateURL(builder);\n                PrivateURL.addVersion(builder, version);\n                PrivateURL.addExpiry(builder, expiry);\n                PrivateURL.addPbkdf2Iters(builder, pbkdf2Iters);\n                PrivateURL.addSalt(builder, saltOffset);\n                PrivateURL.addIv(builder, ivOffset);\n                PrivateURL.addBlindedUrl(builder, blindedUrlOffset);\n                return PrivateURL.endPrivateURL(builder);\n            }\n            /**\n             * @returns PrivateURLT\n             */\n            unpack() {\n                return new PrivateURLT(this.version(), this.expiry(), this.pbkdf2Iters(), this.bb.createScalarList(this.salt.bind(this), this.saltLength()), this.bb.createScalarList(this.iv.bind(this), this.ivLength()), this.bb.createScalarList(this.blindedUrl.bind(this), this.blindedUrlLength()));\n            }\n            ;\n            /**\n             * @param PrivateURLT _o\n             */\n            unpackTo(_o) {\n                _o.version = this.version();\n                _o.expiry = this.expiry();\n                _o.pbkdf2Iters = this.pbkdf2Iters();\n                _o.salt = this.bb.createScalarList(this.salt.bind(this), this.saltLength());\n                _o.iv = this.bb.createScalarList(this.iv.bind(this), this.ivLength());\n                _o.blindedUrl = this.bb.createScalarList(this.blindedUrl.bind(this), this.blindedUrlLength());\n            }\n            ;\n        }\n        fbs.PrivateURL = PrivateURL;\n        class PrivateURLT {\n            /**\n             * @constructor\n             * @param number version\n             * @param flatbuffers.Long expiry\n             * @param number pbkdf2Iters\n             * @param (number)[] salt\n             * @param (number)[] iv\n             * @param (number)[] blindedUrl\n             */\n            constructor(version = 1, expiry = flatbuffers.createLong(0, 0), pbkdf2Iters = 0, salt = [], iv = [], blindedUrl = []) {\n                this.version = version;\n                this.expiry = expiry;\n                this.pbkdf2Iters = pbkdf2Iters;\n                this.salt = salt;\n                this.iv = iv;\n                this.blindedUrl = blindedUrl;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            pack(builder) {\n                const salt = ec_prv.fbs.PrivateURL.createSaltVector(builder, this.salt);\n                const iv = ec_prv.fbs.PrivateURL.createIvVector(builder, this.iv);\n                const blindedUrl = ec_prv.fbs.PrivateURL.createBlindedUrlVector(builder, this.blindedUrl);\n                return ec_prv.fbs.PrivateURL.createPrivateURL(builder, this.version, this.expiry, this.pbkdf2Iters, salt, iv, blindedUrl);\n            }\n            ;\n        }\n        fbs.PrivateURLT = PrivateURLT;\n    })(fbs = ec_prv.fbs || (ec_prv.fbs = {}));\n})(ec_prv = exports.ec_prv || (exports.ec_prv = {}));\n\n\n//# sourceURL=webpack:///./fbs/private_url_generated.ts?");

/***/ }),

/***/ "./fbs/shortening_request_generated.ts":
/*!*********************************************!*\
  !*** ./fbs/shortening_request_generated.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// automatically generated by the FlatBuffers compiler, do not modify\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ec_prv = void 0;\n/**\n * @constructor\n */\nvar ec_prv;\n(function (ec_prv) {\n    var fbs;\n    (function (fbs) {\n        class ShorteningRequest {\n            constructor() {\n                this.bb = null;\n                this.bb_pos = 0;\n            }\n            /**\n             * @param number i\n             * @param flatbuffers.ByteBuffer bb\n             * @returns ShorteningRequest\n             */\n            __init(i, bb) {\n                this.bb_pos = i;\n                this.bb = bb;\n                return this;\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param ShorteningRequest= obj\n             * @returns ShorteningRequest\n             */\n            static getRootAsShorteningRequest(bb, obj) {\n                return (obj || new ShorteningRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param ShorteningRequest= obj\n             * @returns ShorteningRequest\n             */\n            static getSizePrefixedRootAsShorteningRequest(bb, obj) {\n                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n                return (obj || new ShorteningRequest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            version() {\n                var offset = this.bb.__offset(this.bb_pos, 4);\n                return offset ? this.bb.readUint8(this.bb_pos + offset) : 1;\n            }\n            ;\n            /**\n             * @returns flatbuffers.Long\n             */\n            expiry() {\n                var offset = this.bb.__offset(this.bb_pos, 6);\n                return offset ? this.bb.readUint64(this.bb_pos + offset) : this.bb.createLong(0, 0);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            pbkdf2Iters() {\n                var offset = this.bb.__offset(this.bb_pos, 8);\n                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            salt(index) {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            saltLength() {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            saltArray() {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            iv(index) {\n                var offset = this.bb.__offset(this.bb_pos, 12);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            ivLength() {\n                var offset = this.bb.__offset(this.bb_pos, 12);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            ivArray() {\n                var offset = this.bb.__offset(this.bb_pos, 12);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param number index\n             * @returns number\n             */\n            blindedUrl(index) {\n                var offset = this.bb.__offset(this.bb_pos, 14);\n                return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            blindedUrlLength() {\n                var offset = this.bb.__offset(this.bb_pos, 14);\n                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n            }\n            ;\n            /**\n             * @returns Uint8Array\n             */\n            blindedUrlArray() {\n                var offset = this.bb.__offset(this.bb_pos, 14);\n                return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             */\n            static startShorteningRequest(builder) {\n                builder.startObject(6);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number version\n             */\n            static addVersion(builder, version) {\n                builder.addFieldInt8(0, version, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Long expiry\n             */\n            static addExpiry(builder, expiry) {\n                builder.addFieldInt64(1, expiry, builder.createLong(0, 0));\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number pbkdf2Iters\n             */\n            static addPbkdf2Iters(builder, pbkdf2Iters) {\n                builder.addFieldInt32(2, pbkdf2Iters, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset saltOffset\n             */\n            static addSalt(builder, saltOffset) {\n                builder.addFieldOffset(3, saltOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createSaltVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startSaltVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset ivOffset\n             */\n            static addIv(builder, ivOffset) {\n                builder.addFieldOffset(4, ivOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createIvVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startIvVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset blindedUrlOffset\n             */\n            static addBlindedUrl(builder, blindedUrlOffset) {\n                builder.addFieldOffset(5, blindedUrlOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param Array.<number> data\n             * @returns flatbuffers.Offset\n             */\n            static createBlindedUrlVector(builder, data) {\n                builder.startVector(1, data.length, 1);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    builder.addInt8(data[i]);\n                }\n                return builder.endVector();\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number numElems\n             */\n            static startBlindedUrlVector(builder, numElems) {\n                builder.startVector(1, numElems, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            static endShorteningRequest(builder) {\n                var offset = builder.endObject();\n                return offset;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishShorteningRequestBuffer(builder, offset) {\n                builder.finish(offset);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishSizePrefixedShorteningRequestBuffer(builder, offset) {\n                builder.finish(offset, undefined, true);\n            }\n            ;\n            static createShorteningRequest(builder, version, expiry, pbkdf2Iters, saltOffset, ivOffset, blindedUrlOffset) {\n                ShorteningRequest.startShorteningRequest(builder);\n                ShorteningRequest.addVersion(builder, version);\n                ShorteningRequest.addExpiry(builder, expiry);\n                ShorteningRequest.addPbkdf2Iters(builder, pbkdf2Iters);\n                ShorteningRequest.addSalt(builder, saltOffset);\n                ShorteningRequest.addIv(builder, ivOffset);\n                ShorteningRequest.addBlindedUrl(builder, blindedUrlOffset);\n                return ShorteningRequest.endShorteningRequest(builder);\n            }\n            /**\n             * @returns ShorteningRequestT\n             */\n            unpack() {\n                return new ShorteningRequestT(this.version(), this.expiry(), this.pbkdf2Iters(), this.bb.createScalarList(this.salt.bind(this), this.saltLength()), this.bb.createScalarList(this.iv.bind(this), this.ivLength()), this.bb.createScalarList(this.blindedUrl.bind(this), this.blindedUrlLength()));\n            }\n            ;\n            /**\n             * @param ShorteningRequestT _o\n             */\n            unpackTo(_o) {\n                _o.version = this.version();\n                _o.expiry = this.expiry();\n                _o.pbkdf2Iters = this.pbkdf2Iters();\n                _o.salt = this.bb.createScalarList(this.salt.bind(this), this.saltLength());\n                _o.iv = this.bb.createScalarList(this.iv.bind(this), this.ivLength());\n                _o.blindedUrl = this.bb.createScalarList(this.blindedUrl.bind(this), this.blindedUrlLength());\n            }\n            ;\n        }\n        fbs.ShorteningRequest = ShorteningRequest;\n        class ShorteningRequestT {\n            /**\n             * @constructor\n             * @param number version\n             * @param flatbuffers.Long expiry\n             * @param number pbkdf2Iters\n             * @param (number)[] salt\n             * @param (number)[] iv\n             * @param (number)[] blindedUrl\n             */\n            constructor(version = 1, expiry = flatbuffers.createLong(0, 0), pbkdf2Iters = 0, salt = [], iv = [], blindedUrl = []) {\n                this.version = version;\n                this.expiry = expiry;\n                this.pbkdf2Iters = pbkdf2Iters;\n                this.salt = salt;\n                this.iv = iv;\n                this.blindedUrl = blindedUrl;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            pack(builder) {\n                const salt = ec_prv.fbs.ShorteningRequest.createSaltVector(builder, this.salt);\n                const iv = ec_prv.fbs.ShorteningRequest.createIvVector(builder, this.iv);\n                const blindedUrl = ec_prv.fbs.ShorteningRequest.createBlindedUrlVector(builder, this.blindedUrl);\n                return ec_prv.fbs.ShorteningRequest.createShorteningRequest(builder, this.version, this.expiry, this.pbkdf2Iters, salt, iv, blindedUrl);\n            }\n            ;\n        }\n        fbs.ShorteningRequestT = ShorteningRequestT;\n    })(fbs = ec_prv.fbs || (ec_prv.fbs = {}));\n})(ec_prv = exports.ec_prv || (exports.ec_prv = {}));\n\n\n//# sourceURL=webpack:///./fbs/shortening_request_generated.ts?");

/***/ }),

/***/ "./fbs/shortening_response_generated.ts":
/*!**********************************************!*\
  !*** ./fbs/shortening_response_generated.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// automatically generated by the FlatBuffers compiler, do not modify\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ec_prv = void 0;\n/**\n * @constructor\n */\nvar ec_prv;\n(function (ec_prv) {\n    var fbs;\n    (function (fbs) {\n        class ShorteningResponse {\n            constructor() {\n                this.bb = null;\n                this.bb_pos = 0;\n            }\n            /**\n             * @param number i\n             * @param flatbuffers.ByteBuffer bb\n             * @returns ShorteningResponse\n             */\n            __init(i, bb) {\n                this.bb_pos = i;\n                this.bb = bb;\n                return this;\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param ShorteningResponse= obj\n             * @returns ShorteningResponse\n             */\n            static getRootAsShorteningResponse(bb, obj) {\n                return (obj || new ShorteningResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @param flatbuffers.ByteBuffer bb\n             * @param ShorteningResponse= obj\n             * @returns ShorteningResponse\n             */\n            static getSizePrefixedRootAsShorteningResponse(bb, obj) {\n                bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n                return (obj || new ShorteningResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n            }\n            ;\n            /**\n             * @returns number\n             */\n            version() {\n                var offset = this.bb.__offset(this.bb_pos, 4);\n                return offset ? this.bb.readUint8(this.bb_pos + offset) : 1;\n            }\n            ;\n            /**\n             * @returns boolean\n             */\n            error() {\n                var offset = this.bb.__offset(this.bb_pos, 6);\n                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n            }\n            ;\n            /**\n             * @returns number\n             */\n            lookupKey() {\n                var offset = this.bb.__offset(this.bb_pos, 8);\n                return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;\n            }\n            ;\n            lookupKeyEncoded(optionalEncoding) {\n                var offset = this.bb.__offset(this.bb_pos, 10);\n                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             */\n            static startShorteningResponse(builder) {\n                builder.startObject(4);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number version\n             */\n            static addVersion(builder, version) {\n                builder.addFieldInt8(0, version, 1);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param boolean error\n             */\n            static addError(builder, error) {\n                builder.addFieldInt8(1, +error, +false);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param number lookupKey\n             */\n            static addLookupKey(builder, lookupKey) {\n                builder.addFieldInt32(2, lookupKey, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset lookupKeyEncodedOffset\n             */\n            static addLookupKeyEncoded(builder, lookupKeyEncodedOffset) {\n                builder.addFieldOffset(3, lookupKeyEncodedOffset, 0);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            static endShorteningResponse(builder) {\n                var offset = builder.endObject();\n                return offset;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishShorteningResponseBuffer(builder, offset) {\n                builder.finish(offset);\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @param flatbuffers.Offset offset\n             */\n            static finishSizePrefixedShorteningResponseBuffer(builder, offset) {\n                builder.finish(offset, undefined, true);\n            }\n            ;\n            static createShorteningResponse(builder, version, error, lookupKey, lookupKeyEncodedOffset) {\n                ShorteningResponse.startShorteningResponse(builder);\n                ShorteningResponse.addVersion(builder, version);\n                ShorteningResponse.addError(builder, error);\n                ShorteningResponse.addLookupKey(builder, lookupKey);\n                ShorteningResponse.addLookupKeyEncoded(builder, lookupKeyEncodedOffset);\n                return ShorteningResponse.endShorteningResponse(builder);\n            }\n            /**\n             * @returns ShorteningResponseT\n             */\n            unpack() {\n                return new ShorteningResponseT(this.version(), this.error(), this.lookupKey(), this.lookupKeyEncoded());\n            }\n            ;\n            /**\n             * @param ShorteningResponseT _o\n             */\n            unpackTo(_o) {\n                _o.version = this.version();\n                _o.error = this.error();\n                _o.lookupKey = this.lookupKey();\n                _o.lookupKeyEncoded = this.lookupKeyEncoded();\n            }\n            ;\n        }\n        fbs.ShorteningResponse = ShorteningResponse;\n        class ShorteningResponseT {\n            /**\n             * @constructor\n             * @param number version\n             * @param boolean error\n             * @param number lookupKey\n             * @param string|Uint8Array|null lookupKeyEncoded\n             */\n            constructor(version = 1, error = false, lookupKey = 0, lookupKeyEncoded = null) {\n                this.version = version;\n                this.error = error;\n                this.lookupKey = lookupKey;\n                this.lookupKeyEncoded = lookupKeyEncoded;\n            }\n            ;\n            /**\n             * @param flatbuffers.Builder builder\n             * @returns flatbuffers.Offset\n             */\n            pack(builder) {\n                const lookupKeyEncoded = (this.lookupKeyEncoded !== null ? builder.createString(this.lookupKeyEncoded) : 0);\n                return ec_prv.fbs.ShorteningResponse.createShorteningResponse(builder, this.version, this.error, this.lookupKey, lookupKeyEncoded);\n            }\n            ;\n        }\n        fbs.ShorteningResponseT = ShorteningResponseT;\n    })(fbs = ec_prv.fbs || (ec_prv.fbs = {}));\n})(ec_prv = exports.ec_prv || (exports.ec_prv = {}));\n\n\n//# sourceURL=webpack:///./fbs/shortening_response_generated.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_1 = __webpack_require__(/*! ./client */ \"./client/index.ts\");\n(function () {\n    document.querySelector('#urlForm').addEventListener('submit', async (evt) => {\n        evt.preventDefault();\n        const form = evt.target;\n        const urlInputElement = document.querySelector('#url');\n        const url = urlInputElement.value.trim();\n        const client = new client_1.ShortenerClient();\n        // TODO: display progress bar\n        const shortened_url_route = await client.shorten(url);\n        const shortened_url = window.location.protocol +\n            '//' +\n            window.location.host +\n            '/' +\n            shortened_url_route;\n        const outputLink = document.querySelector('#shortenedUrlResultLink');\n        outputLink.href = shortened_url;\n        outputLink.textContent = shortened_url;\n    });\n    if (window.location.pathname != '/' && window.location.pathname != '/index.html') {\n        (async () => {\n            try {\n                const identifier = window.location.pathname.slice(1);\n                const pass = window.location.hash.slice(1);\n                if (identifier.length === 0 || pass.length === 0) {\n                    return;\n                }\n                const client = new client_1.LookupClient(identifier, pass);\n                // TODO: display progress bar while deriving key\n                const urlPlaintext = await client.lookup();\n                console.info(`redirecting to: ${urlPlaintext}`);\n                window.location.replace(urlPlaintext);\n            }\n            catch (e) {\n                console.error(e);\n                window.location.replace('/');\n            }\n        })();\n    }\n})();\n\n\n//# sourceURL=webpack:///./index.ts?");

/***/ }),

/***/ "./rpc/common.ts":
/*!***********************!*\
  !*** ./rpc/common.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.post = void 0;\nasync function post(name, message) {\n    const r = await window.fetch('/accept', {\n        method: 'POST',\n        headers: {\n            'x-rpc-method': name,\n        },\n        body: new Uint8Array(message),\n    });\n    console.log(message);\n    if (r.status == 200) {\n        const resp = await r.arrayBuffer();\n        return resp;\n    }\n}\nexports.post = post;\n\n\n//# sourceURL=webpack:///./rpc/common.ts?");

/***/ }),

/***/ "./rpc/index.ts":
/*!**********************!*\
  !*** ./rpc/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./lookup */ \"./rpc/lookup.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./shorten */ \"./rpc/shorten.ts\"), exports);\n\n\n//# sourceURL=webpack:///./rpc/index.ts?");

/***/ }),

/***/ "./rpc/lookup.ts":
/*!***********************!*\
  !*** ./rpc/lookup.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lookupRequestWeb = exports.lookupRequestV1 = void 0;\nconst flatbuffers_1 = __webpack_require__(/*! ../vendor/flatbuffers/flatbuffers */ \"./vendor/flatbuffers/flatbuffers.js\");\nconst lookup_request = __importStar(__webpack_require__(/*! ../fbs/lookup_request_generated */ \"./fbs/lookup_request_generated.ts\"));\nconst lookup_response = __importStar(__webpack_require__(/*! ../fbs/lookup_response_generated */ \"./fbs/lookup_response_generated.ts\"));\nconst lookup_request_web = __importStar(__webpack_require__(/*! ../fbs/lookup_request_web_generated */ \"./fbs/lookup_request_web_generated.ts\"));\nconst { LookupRequest, LookupRequestT } = lookup_request.ec_prv.fbs;\nconst { LookupRequestWeb } = lookup_request_web.ec_prv.fbs;\nconst { LookupResponse, LookupResponseT } = lookup_response.ec_prv.fbs;\nconst common_1 = __webpack_require__(/*! ./common */ \"./rpc/common.ts\");\nasync function lookupRequestV1(urlIndex) {\n    /* const urlIndexFbb = new flatbuffers.Builder();\n    const ui = urlIndex.pack(urlIndexFbb);\n    urlIndexFbb.finish(ui);\n    const reqFbb = new flatbuffers.Builder();\n    const lkv = LookupRequest.createLookupKeyVector(reqFbb, urlIndexFbb.asUint8Array());\n    LookupRequest.startLookupRequest(reqFbb);\n    LookupRequest.addVersion(reqFbb, 1);\n    LookupRequest.addLookupKey(reqFbb, lkv);\n    const lr = LookupRequest.endLookupRequest(reqFbb);\n    reqFbb.finish(lr);\n    const resp = await post('lookup_request', reqFbb.asuUint8Array());\n    if (resp == null) {\n        return null;\n    }\n    const lookupResponse = LookupResponse.getRootAsLookupResponse(new flatbuffers.ByteBuffer(new Uint8Array(resp)));\n    return lookupResponse.unpack(); */\n    throw new Error(\"unimplemented\");\n}\nexports.lookupRequestV1 = lookupRequestV1;\nasync function lookupRequestWeb(urlIndex) {\n    const fbb = new flatbuffers_1.flatbuffers.Builder();\n    const lk = fbb.createString(urlIndex);\n    LookupRequestWeb.startLookupRequestWeb(fbb);\n    LookupRequestWeb.addLookupKey(fbb, lk);\n    const lrw = LookupRequestWeb.endLookupRequestWeb(fbb);\n    fbb.finish(lrw);\n    const fb = fbb.asUint8Array();\n    const resp = await common_1.post('lookup_request_web', fb);\n    if (resp == null) {\n        return null;\n    }\n    const lookupResponse = LookupResponse.getRootAsLookupResponse(new flatbuffers_1.flatbuffers.ByteBuffer(new Uint8Array(resp)));\n    return lookupResponse.unpack();\n}\nexports.lookupRequestWeb = lookupRequestWeb;\n\n\n//# sourceURL=webpack:///./rpc/lookup.ts?");

/***/ }),

/***/ "./rpc/shorten.ts":
/*!************************!*\
  !*** ./rpc/shorten.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shorteningRequestV1 = void 0;\nconst shortening_request = __importStar(__webpack_require__(/*! ../fbs/shortening_request_generated */ \"./fbs/shortening_request_generated.ts\"));\nconst shortening_response = __importStar(__webpack_require__(/*! ../fbs/shortening_response_generated */ \"./fbs/shortening_response_generated.ts\"));\nconst private_url = __importStar(__webpack_require__(/*! ../fbs/private_url_generated */ \"./fbs/private_url_generated.ts\"));\nconst { ShorteningRequestT, ShorteningRequest } = shortening_request.ec_prv.fbs;\nconst { ShorteningResponseT, ShorteningResponse, } = shortening_response.ec_prv.fbs;\nconst { PrivateURL, PrivateURLT } = private_url.ec_prv.fbs;\nconst flatbuffers_1 = __webpack_require__(/*! ../vendor/flatbuffers/flatbuffers */ \"./vendor/flatbuffers/flatbuffers.js\");\nconst common_1 = __webpack_require__(/*! ./common */ \"./rpc/common.ts\");\nconst util_1 = __webpack_require__(/*! ../util */ \"./util/index.ts\");\n/**\n * Makes a request to shorten a URL and returns the generated identifier representing the shortened URL.\n * @param {Uint8Array} blindedUrl - the ciphertext of the URL\n * @param {Uint8Array} iv - initialization vector used to encrypt blindedUrl\n * @param {Uint8Array} salt - salt used to derive the key used to encrypt blindedUrl\n * @returns {Promise<string>} Promise object represents the identifier associated with the successfully generated record; for example, the returned string would be \"IDENTIFIER\" in \"https://prv.ec/IDENTIFIER#p4ss\". If the request fails, an empty string is returned.\n */\nasync function shorteningRequestV1(blindedUrl, iv, salt, expiry) {\n    const fbb = new flatbuffers_1.flatbuffers.Builder();\n    const expiryAsSeconds = util_1.toLong(Math.floor(expiry.getTime() / 1000));\n    const saltVec = ShorteningRequest.createSaltVector(fbb, salt);\n    const ivVec = ShorteningRequest.createIvVector(fbb, iv);\n    const blindedUrlVector = ShorteningRequest.createBlindedUrlVector(fbb, blindedUrl);\n    ShorteningRequest.startShorteningRequest(fbb);\n    ShorteningRequest.addExpiry(fbb, expiryAsSeconds);\n    ShorteningRequest.addVersion(fbb, 1);\n    ShorteningRequest.addIv(fbb, ivVec);\n    ShorteningRequest.addSalt(fbb, saltVec);\n    ShorteningRequest.addPbkdf2Iters(fbb, 2000000);\n    ShorteningRequest.addBlindedUrl(fbb, blindedUrlVector);\n    const sr = ShorteningRequest.endShorteningRequest(fbb);\n    fbb.finish(sr);\n    const resp = await common_1.post('shortening_request', fbb.asUint8Array());\n    if (resp == null) {\n        return '';\n    }\n    const responseFbObject = ShorteningResponse.getRootAsShorteningResponse(new flatbuffers_1.flatbuffers.ByteBuffer(new Uint8Array(resp)));\n    if (responseFbObject.error()) {\n        return '';\n    }\n    const responseObj = responseFbObject.unpack();\n    return responseObj.lookupKeyEncoded;\n}\nexports.shorteningRequestV1 = shorteningRequestV1;\n\n\n//# sourceURL=webpack:///./rpc/shorten.ts?");

/***/ }),

/***/ "./util/base64.ts":
/*!************************!*\
  !*** ./util/base64.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromURLSafeBase64 = exports.toURLSafeBase64 = exports.toByteArray = exports.fromByteArray = void 0;\n/**\n * Encodes a byte array to a base64-encoded string.\n * @param {Uint8Array} bytes - byte array\n * @returns {string} url-safe base64-encoded string\n */\nfunction fromByteArray(bytes) {\n    let s = '';\n    for (let i = 0; i < bytes.byteLength; ++i) {\n        s += String.fromCharCode(bytes[i]);\n    }\n    let b = window.btoa(s);\n    const urlSafeStr = b.replace('+', '-').replace('/', '_');\n    return urlSafeStr;\n}\nexports.fromByteArray = fromByteArray;\nfunction toByteArray(base64EncodedString) {\n    if (isURLSafe(base64EncodedString)) {\n        base64EncodedString = fromURLSafeBase64(base64EncodedString);\n    }\n    const decoded = window.atob(base64EncodedString);\n    const r = new Array(decoded.length);\n    for (let i = 0; i < decoded.length; ++i) {\n        r[i] = decoded.charCodeAt(i);\n    }\n    return new Uint8Array(r);\n}\nexports.toByteArray = toByteArray;\nfunction toURLSafeBase64(s) {\n    return s.replace('+', '-').replace('/', '_');\n}\nexports.toURLSafeBase64 = toURLSafeBase64;\nfunction fromURLSafeBase64(s) {\n    return s.replace('-', '+').replace('_', '/');\n}\nexports.fromURLSafeBase64 = fromURLSafeBase64;\nfunction isURLSafe(s) {\n    return s.indexOf('-') !== -1 || s.indexOf('_') !== -1;\n}\n\n\n//# sourceURL=webpack:///./util/base64.ts?");

/***/ }),

/***/ "./util/fbLong.ts":
/*!************************!*\
  !*** ./util/fbLong.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toLong = void 0;\nconst flatbuffers_1 = __webpack_require__(/*! ../vendor/flatbuffers/flatbuffers */ \"./vendor/flatbuffers/flatbuffers.js\");\nfunction toLong(n) {\n    let binaryString = n.toString(2);\n    binaryString = binaryString.padStart(64, '0');\n    const high = window.parseInt(binaryString.substr(0, 32), 2);\n    const low = window.parseInt(binaryString.substr(32), 2);\n    return flatbuffers_1.flatbuffers.createLong(low, high);\n}\nexports.toLong = toLong;\n\n\n//# sourceURL=webpack:///./util/fbLong.ts?");

/***/ }),

/***/ "./util/index.ts":
/*!***********************!*\
  !*** ./util/index.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./fbLong */ \"./util/fbLong.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./base64 */ \"./util/base64.ts\"), exports);\n\n\n//# sourceURL=webpack:///./util/index.ts?");

/***/ }),

/***/ "./vendor/flatbuffers/flatbuffers.js":
/*!*******************************************!*\
  !*** ./vendor/flatbuffers/flatbuffers.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZE_PREFIX_LENGTH = 4;\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {flatbuffers.Long}\n */\nflatbuffers.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {!flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n  this.string_maps = null;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {!Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n * @param {boolean=} opt_size_prefix\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {\n  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);\n  this.addOffset(root_table);\n  if (size_prefix) {\n    this.addInt32(this.bb.capacity() - this.space);\n  }\n  this.bb.setPosition(this.space);\n};\n\n/**\n * Finalize a size prefixed buffer, pointing to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {\n  this.finish(root_table, opt_file_identifier, true);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If the string passed has \n * already been seen, we return the offset of the already written string\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createSharedString = function(s) {\n  if (!s) { return 0 }\n\n  if (!this.string_maps) {\n    this.string_maps = new Map();\n  }\n\n  if (this.string_maps.has(s)) {\n    return this.string_maps.get(s)\n  }\n  let offset = this.createString(s)\n  this.string_maps.set(s, offset)\n  return offset\n}\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (!s) { return 0 }\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n/**\n * A helper function to pack an object\n * \n * @returns offset of obj\n */\nflatbuffers.Builder.prototype.createObjectOffset = function(obj) {\n  if(obj === null) {\n    return 0\n  }\n\n  if(typeof obj === 'string') {\n    return this.createString(obj);\n  } else {\n    return obj.pack(this);\n  }\n}\n\n/**\n * A helper function to pack a list of object\n * \n * @returns list of offsets of each non null object\n */\nflatbuffers.Builder.prototype.createObjectOffsetList = function(list) {\n  let ret = [];\n\n  for(let i = 0; i < list.length; ++i) {\n    let val = list[i];\n\n    if(val !== null) {\n      ret.push(this.createObjectOffset(val));\n    } else {\n      throw new Error(\n        'FlatBuffers: Argument for createObjectOffsetList cannot contain null.'); \n    }\n  }\n  \n  return ret;\n};\n\nflatbuffers.Builder.prototype.createStructOffsetList = function(list, startFunc) {\n  startFunc(this, list.length);\n  this.createObjectOffsetList(list);\n  return this.endVector();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {!flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|!Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Handle unions that can contain string as its member, if a Table-derived type then initialize it, \n * if a string then return a new one\n * \n * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this \n * makes the behaviour of __union_with_string different compared to __union\n *\n * @param {flatbuffers.Table|string} o\n * @param {number} offset\n * @returns {flatbuffers.Table|string}\n */\nflatbuffers.ByteBuffer.prototype.__union_with_string = function(o, offset) {\n  if(typeof o === 'string') {\n    return this.__string(offset);\n  } \n  return this.__union(o, offset);\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n/**\n * A helper function for generating list for obj api\n * @param listAccessor function that accepts an index and return data at that index\n * @param {number} listLength\n * @returns {any[]}\n */\nflatbuffers.ByteBuffer.prototype.createScalarList = function(listAccessor, listLength) {\n  let ret = [];\n  for(let i = 0; i < listLength; ++i) {\n    if(listAccessor(i) !== null) {\n      ret.push(listAccessor(i));\n    }\n  }\n\n  return ret;\n};\n\n/**\n * This function is here only to get around typescript type system\n */\nflatbuffers.ByteBuffer.prototype.createStringList = function(listAccessor, listLength) {\n  return this.createScalarList(listAccessor, listLength);\n};\n\n/**\n * A helper function for generating list for obj api\n * @param listAccessor function that accepts an index and return data at that index\n * @param listLength {number} listLength\n * @param res any[] result list\n */\nflatbuffers.ByteBuffer.prototype.createObjList = function(listAccessor, listLength) {\n  let ret = [];\n  for(let i = 0; i < listLength; ++i) {\n    let val = listAccessor(i);\n    if(val !== null) {\n      ret.push(val.unpack());\n    }\n  }\n  \n  return ret;\n};\n\n// Exports for Node.js and RequireJS\nthis.flatbuffers = flatbuffers;\n// exports.default = flatbuffers;\n// exports.flatbuffers = flatbuffers;\n\n/// @endcond\n/// @}\n\n\n//# sourceURL=webpack:///./vendor/flatbuffers/flatbuffers.js?");

/***/ })

/******/ });